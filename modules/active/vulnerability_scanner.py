"""
Vulnerability Scanner Module
Performs comprehensive vulnerability scanning using multiple techniques.
"""

import logging
import asyncio
import aiohttp
import re
import json
import time
from typing import Dict, Any, List, Optional
from urllib.parse import urljoin, urlparse
from modules.base_module import BaseModule


class VulnerabilityScanner(BaseModule):
    """Advanced vulnerability scanning module."""
    
    def __init__(self):
        super().__init__(
            name="Vulnerability Scanner",
            description="Comprehensive vulnerability scanning including CVE detection, security headers, and common vulnerabilities",
            category="active"
        )
        
        self.logger = logging.getLogger(__name__)
        self._stop_requested = False
        self._vulnerabilities = []
        
        # Common vulnerability patterns
        self.vuln_patterns = {
            'sql_injection': [
                r'mysql_fetch_array\(\)',
                r'ORA-[0-9]{5}',
                r'Microsoft.*ODBC.*SQL Server',
                r'PostgreSQL.*ERROR',
                r'Warning.*mysql_.*',
                r'valid MySQL result',
                r'MySqlClient\.',
                r'com\.mysql\.jdbc',
                r'Zend_Db_(Select|Adapter)',
                r'(PDO|SQLSTATE)\[[0-9]{5}\]'
            ],
            'xss': [
                r'<script[^>]*>.*?</script>',
                r'javascript:',
                r'on\w+\s*=',
                r'<iframe[^>]*>',
                r'<object[^>]*>',
                r'<embed[^>]*>'
            ],
            'lfi': [
                r'Warning.*include\(\)',
                r'Warning.*require\(\)',
                r'Failed opening.*for inclusion',
                r'No such file or directory in',
                r'open_basedir restriction in effect'
            ],
            'rfi': [
                r'Warning.*URL file-access is disabled',
                r'Warning.*fopen\(\)',
                r'for inclusion.*stream does not support',
                r'Failed opening.*for inclusion'
            ],
            'directory_traversal': [
                r'root:x:0:0:',
                r'\[boot loader\]',
                r'<DIR>',
                r'Volume.*Serial Number'
            ],
            'xxe': [
                r'<!ENTITY',
                r'ENTITY.*SYSTEM',
                r'xml version.*encoding'
            ]
        }
        
        # Security headers to check
        self.security_headers = {
            'Strict-Transport-Security': 'HSTS not implemented',
            'Content-Security-Policy': 'CSP not implemented',
            'X-Frame-Options': 'Clickjacking protection missing',
            'X-Content-Type-Options': 'MIME type sniffing not prevented',
            'X-XSS-Protection': 'XSS protection not enabled',
            'Referrer-Policy': 'Referrer policy not set',
            'Permissions-Policy': 'Permissions policy not set',
            'Cross-Origin-Embedder-Policy': 'COEP not implemented',
            'Cross-Origin-Opener-Policy': 'COOP not implemented',
            'Cross-Origin-Resource-Policy': 'CORP not implemented'
        }

    def get_input_fields(self) -> List[Dict[str, Any]]:
        return [
            {
                'name': 'target_url',
                'type': 'text',
                'label': 'Target URL',
                'required': True,
                'default': '',
                'placeholder': 'https://example.com'
            },
            {
                'name': 'scan_depth',
                'type': 'combo',
                'label': 'Scan Depth',
                'required': False,
                'default': 'medium',
                'options': ['light', 'medium', 'deep', 'comprehensive'],
                'tooltip': 'Depth of vulnerability scanning'
            },
            {
                'name': 'include_headers',
                'type': 'checkbox',
                'label': 'Check Security Headers',
                'required': False,
                'default': True
            },
            {
                'name': 'include_ssl',
                'type': 'checkbox',
                'label': 'SSL/TLS Analysis',
                'required': False,
                'default': True
            },
            {
                'name': 'include_cve',
                'type': 'checkbox',
                'label': 'CVE Detection',
                'required': False,
                'default': True
            },
            {
                'name': 'custom_payloads',
                'type': 'file',
                'label': 'Custom Payloads File',
                'required': False,
                'default': '',
                'tooltip': 'Text file with custom vulnerability payloads'
            },
            {
                'name': 'threads',
                'type': 'number',
                'label': 'Concurrent Threads',
                'required': False,
                'default': 10,
                'min': 1,
                'max': 50
            },
            {
                'name': 'timeout',
                'type': 'number',
                'label': 'Request Timeout (seconds)',
                'required': False,
                'default': 15,
                'min': 5,
                'max': 60
            }
        ]

    def validate_inputs(self, inputs: Dict[str, Any]) -> Optional[str]:
        target_url = inputs.get('target_url', '').strip()
        if not target_url:
            return "Target URL is required"
        
        if not target_url.startswith(('http://', 'https://')):
            return "Target URL must start with http:// or https://"
        
        try:
            parsed = urlparse(target_url)
            if not parsed.netloc:
                return "Invalid URL format"
        except Exception:
            return "Invalid URL format"
        
        return None

    async def check_security_headers(self, session: aiohttp.ClientSession, url: str) -> Dict[str, Any]:
        """Check for security headers."""
        self.update_progress("Checking security headers...", 10)
        
        try:
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                headers = dict(response.headers)
                missing_headers = []
                present_headers = []
                
                for header, description in self.security_headers.items():
                    if header not in headers:
                        missing_headers.append({
                            'header': header,
                            'description': description,
                            'severity': 'medium' if header in ['Strict-Transport-Security', 'Content-Security-Policy'] else 'low'
                        })
                    else:
                        present_headers.append({
                            'header': header,
                            'value': headers[header]
                        })
                
                return {
                    'missing_headers': missing_headers,
                    'present_headers': present_headers,
                    'all_headers': headers
                }
        except Exception as e:
            self.logger.error(f"Error checking security headers: {e}")
            return {'error': str(e)}

    async def check_ssl_tls(self, session: aiohttp.ClientSession, url: str) -> Dict[str, Any]:
        """Check SSL/TLS configuration."""
        self.update_progress("Analyzing SSL/TLS configuration...", 25)
        
        try:
            # Basic SSL check
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                ssl_info = {
                    'protocol': getattr(response.connection.transport.get_extra_info('ssl_object'), 'version', 'Unknown'),
                    'cipher': getattr(response.connection.transport.get_extra_info('ssl_object'), 'cipher', 'Unknown'),
                    'server_hostname': getattr(response.connection.transport.get_extra_info('ssl_object'), 'server_hostname', 'Unknown')
                }
                
                # Check for HTTPS
                is_https = url.startswith('https://')
                
                # Check HSTS header
                hsts_header = response.headers.get('Strict-Transport-Security')
                
                return {
                    'is_https': is_https,
                    'ssl_info': ssl_info,
                    'hsts_enabled': bool(hsts_header),
                    'hsts_header': hsts_header
                }
        except Exception as e:
            self.logger.error(f"Error checking SSL/TLS: {e}")
            return {'error': str(e)}

    async def test_common_vulnerabilities(self, session: aiohttp.ClientSession, base_url: str, scan_depth: str) -> List[Dict[str, Any]]:
        """Test for common web vulnerabilities."""
        self.update_progress("Testing for common vulnerabilities...", 50)
        
        vulnerabilities = []
        
        # SQL Injection payloads
        sql_payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' OR 1=1#",
            "admin'--",
            "' OR 'x'='x",
            "1' AND 1=1--",
            "1' WAITFOR DELAY '00:00:05'--"
        ]
        
        # XSS payloads
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//",
            "\"><script>alert('XSS')</script>",
            "<iframe src=javascript:alert('XSS')></iframe>"
        ]
        
        # LFI/Directory Traversal payloads
        lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "../../../../etc/shadow",
            "../../../proc/version",
            "..\\..\\..\\boot.ini"
        ]
        
        test_params = ['id', 'page', 'file', 'include', 'cat', 'dir', 'search', 'q', 'query']
        
        for param in test_params:
            if not self.should_continue():
                break
                
            # Test SQL Injection
            for payload in sql_payloads[:3 if scan_depth == 'light' else len(sql_payloads)]:
                try:
                    test_url = f"{base_url}?{param}={payload}"
                    async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        content = await response.text()
                        
                        for vuln_type, patterns in self.vuln_patterns.items():
                            if vuln_type == 'sql_injection':
                                for pattern in patterns:
                                    if re.search(pattern, content, re.IGNORECASE):
                                        vulnerabilities.append({
                                            'type': 'SQL Injection',
                                            'severity': 'high',
                                            'url': test_url,
                                            'parameter': param,
                                            'payload': payload,
                                            'evidence': pattern,
                                            'description': 'Potential SQL injection vulnerability detected'
                                        })
                                        break
                except Exception as e:
                    continue
            
            # Test XSS
            for payload in xss_payloads[:2 if scan_depth == 'light' else len(xss_payloads)]:
                try:
                    test_url = f"{base_url}?{param}={payload}"
                    async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        content = await response.text()
                        
                        if payload in content:
                            vulnerabilities.append({
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'medium',
                                'url': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': 'Payload reflected in response',
                                'description': 'Potential XSS vulnerability detected'
                            })
                except Exception as e:
                    continue
            
            # Test LFI/Directory Traversal
            for payload in lfi_payloads[:2 if scan_depth == 'light' else len(lfi_payloads)]:
                try:
                    test_url = f"{base_url}?{param}={payload}"
                    async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        content = await response.text()
                        
                        for pattern in self.vuln_patterns['directory_traversal']:
                            if re.search(pattern, content, re.IGNORECASE):
                                vulnerabilities.append({
                                    'type': 'Directory Traversal/LFI',
                                    'severity': 'high',
                                    'url': test_url,
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': pattern,
                                    'description': 'Potential directory traversal vulnerability detected'
                                })
                                break
                except Exception as e:
                    continue
        
        return vulnerabilities

    async def check_cve_detection(self, session: aiohttp.ClientSession, url: str) -> List[Dict[str, Any]]:
        """Basic CVE detection based on server headers and responses."""
        self.update_progress("Checking for known CVEs...", 75)
        
        cve_findings = []
        
        try:
            async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                server_header = response.headers.get('Server', '')
                x_powered_by = response.headers.get('X-Powered-By', '')
                
                # Check for outdated software versions
                if 'Apache/2.2' in server_header:
                    cve_findings.append({
                        'cve': 'CVE-2017-15710',
                        'severity': 'medium',
                        'description': 'Apache HTTP Server 2.2.x - Out of bounds write vulnerability',
                        'evidence': server_header
                    })
                
                if 'nginx/1.1' in server_header:
                    cve_findings.append({
                        'cve': 'CVE-2013-2028',
                        'severity': 'medium',
                        'description': 'Nginx 1.1.x - Stack-based buffer overflow',
                        'evidence': server_header
                    })
                
                if 'PHP/5.' in x_powered_by:
                    cve_findings.append({
                        'cve': 'CVE-2019-11043',
                        'severity': 'critical',
                        'description': 'PHP 5.x - Remote code execution vulnerability',
                        'evidence': x_powered_by
                    })
                
        except Exception as e:
            self.logger.error(f"Error in CVE detection: {e}")
        
        return cve_findings

    def run_scan(self, inputs: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Run the vulnerability scan."""
        target_url = inputs.get('target_url').strip()
        scan_depth = inputs.get('scan_depth', 'medium')
        include_headers = inputs.get('include_headers', True)
        include_ssl = inputs.get('include_ssl', True)
        include_cve = inputs.get('include_cve', True)
        threads = inputs.get('threads', 10)
        timeout = inputs.get('timeout', 15)
        
        start_time = time.time()
        self._stop_requested = False
        self._vulnerabilities = []
        
        # Run async scan
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            results = loop.run_until_complete(
                self._run_async_scan(target_url, scan_depth, include_headers, 
                                   include_ssl, include_cve, threads, timeout)
            )
        finally:
            loop.close()
        
        scan_time = time.time() - start_time
        
        # Generate summary
        total_vulns = len(results.get('vulnerabilities', []))
        critical_vulns = len([v for v in results.get('vulnerabilities', []) if v.get('severity') == 'critical'])
        high_vulns = len([v for v in results.get('vulnerabilities', []) if v.get('severity') == 'high'])
        medium_vulns = len([v for v in results.get('vulnerabilities', []) if v.get('severity') == 'medium'])
        low_vulns = len([v for v in results.get('vulnerabilities', []) if v.get('severity') == 'low'])
        
        results['summary'] = {
            'target': target_url,
            'scan_time': round(scan_time, 2),
            'scan_depth': scan_depth,
            'total_vulnerabilities': total_vulns,
            'critical': critical_vulns,
            'high': high_vulns,
            'medium': medium_vulns,
            'low': low_vulns,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        
        return results

    async def _run_async_scan(self, target_url: str, scan_depth: str, include_headers: bool,
                            include_ssl: bool, include_cve: bool, threads: int, timeout: int) -> Dict[str, Any]:
        """Run the async vulnerability scan."""
        
        connector = aiohttp.TCPConnector(limit=threads, limit_per_host=threads)
        timeout_config = aiohttp.ClientTimeout(total=timeout)
        
        async with aiohttp.ClientSession(
            connector=connector,
            timeout=timeout_config,
            headers={'User-Agent': self.get_user_agent()}
        ) as session:
            
            results = {
                'vulnerabilities': [],
                'security_headers': {},
                'ssl_analysis': {},
                'cve_findings': []
            }
            
            # Security headers check
            if include_headers:
                results['security_headers'] = await self.check_security_headers(session, target_url)
                if results['security_headers'].get('missing_headers'):
                    for header in results['security_headers']['missing_headers']:
                        results['vulnerabilities'].append({
                            'type': 'Security Header Missing',
                            'severity': header['severity'],
                            'url': target_url,
                            'parameter': header['header'],
                            'payload': 'N/A',
                            'evidence': header['description'],
                            'description': f"Security header {header['header']} is missing"
                        })
            
            # SSL/TLS analysis
            if include_ssl and target_url.startswith('https://'):
                results['ssl_analysis'] = await self.check_ssl_tls(session, target_url)
                if not results['ssl_analysis'].get('hsts_enabled'):
                    results['vulnerabilities'].append({
                        'type': 'HSTS Not Enabled',
                        'severity': 'medium',
                        'url': target_url,
                        'parameter': 'HSTS',
                        'payload': 'N/A',
                        'evidence': 'Strict-Transport-Security header missing',
                        'description': 'HTTP Strict Transport Security (HSTS) is not enabled'
                    })
            
            # Common vulnerability tests
            common_vulns = await self.test_common_vulnerabilities(session, target_url, scan_depth)
            results['vulnerabilities'].extend(common_vulns)
            
            # CVE detection
            if include_cve:
                results['cve_findings'] = await self.check_cve_detection(session, target_url)
                for cve in results['cve_findings']:
                    results['vulnerabilities'].append({
                        'type': 'Known CVE',
                        'severity': cve['severity'],
                        'url': target_url,
                        'parameter': cve['cve'],
                        'payload': 'N/A',
                        'evidence': cve['evidence'],
                        'description': cve['description']
                    })
            
            self.update_progress("Vulnerability scan completed", 100)
            return results

    def stop_scan(self):
        """Stop the vulnerability scan."""
        self._stop_requested = True
        self.logger.info("Vulnerability scan stop requested")
